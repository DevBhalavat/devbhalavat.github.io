---
title: scriptCTF 2025
description: Writeups and solve scripts for scriptCTF 2025
date: 2025-08-18 23:00:00 +0530
categories: [CTF]
tags: []
image: /assets/images/scriptctf25/title.png
math: true
---

> Solve Scripts are AI enhanced for better context and readibility. I also did not store flags and at the time of writing this, instanes do not work, so some of the challenges might not have flags attached with them.
{: .prompt-tip }

## Misc

### Read the Rules

> Read the rules. They can be found in the #rules channel in discord, or here. The rules will contain a link, which will ultimately contain the flag.

Follow the links: `https://play.scriptsorcerers.xyz/rules` -> `https://play.scriptsorcerers.xyz/prizes`

Flag: `scriptCTF{600D_1ucK_5011D3r1}`

### Div

> I love division

The script wants us to input such a number that the output becomes 0. In division, larger the denominator, smaller the answer. In short, $\lim_{q \to \infty} \frac{p}{q} = 0$. The decimal module in python accepts `Infinity` as a valid input, so we can use this to get out flag.

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *

context.update(arch='amd64', os='linux')

host, port = 'play.scriptsorcerers.xyz', 10325
io = remote(host, port)

payload = b'Infinity'

io.recvuntil(b'Enter a number: ')
io.sendline(payload)

try:
    print(io.recvall(timeout=2).decode().strip())
except EOFError:
    print("Connection closed unexpectedly.")

io.close()
```

### emoji

>Emojis everywhere! Is it a joke? Or something is hiding behind it.

This is a relatively easy challenge. If we correlate the unicode offsets of [Domino Tiles](https://en.wikipedia.org/wiki/Domino_Tiles) and the standard [ASCII](https://en.wikipedia.org/wiki/ASCII) values, we find that the chars map to `scr...` and so on. 

![Domino Tiles](/assets/images/scriptctf25/Domino.png)
![ASCII](/assets/images/scriptctf25/ASCII.png)

Doing this for the complete sequence gives us the flag which is: `scriptCTF{3m0j1_3nc0d1ng_1s_w31rd_4nd_fun!1e46d}`.

### Enchant

> I was playing minecraft, and found this strange enchantment on the enchantment table. Can you figure out what it is? Wrap the flag in scriptCTF{}

The enchanting table in minecraft used the Standard Galactic Alphabet font/encoding scheme to display its enchantments. Putting the text into [decode.fr](https://www.dcode.fr/standard-galactic-alphabet), can give us the flag.

![Enchant](/assets/images/scriptctf25/enchant.png)

After a bit of trial and error, the flag is: `scriptCTF{minecraftisfun}`

### Div 2

> Some might call this a programming challenge...

The program generates a random 128-bit secret number. For each query, we can provide a number N and the program returns int(secret / N). The condition `assert int(fl_num).bit_length() == secret.bit_length()`  forces our input number to also be a 128-bit value.

This essentially sets up a comparison oracle:
- If `secret / N >= 1`, the result is at least `1`, meaning `secret >= N`.
- If `secret / N < 1`, the result is `0`, meaning `secret < N`.

With this, we can perform a binary search in the range `[2^127, 2^128)` to gradually narrow down the secret. After ~128 iterations, we will get the exact secret and can submit it to obtain the flag.

```python
#!/usr/bin/env python3
from pwn import *
import decimal

decimal.getcontext().prec = 200

io = remote('play.scriptsorcerers.xyz', 10325)

low = decimal.Decimal(1 << 127)
high = decimal.Decimal(1 << 128)

for _ in range(130):
    N = (low + high) / 2
    io.sendlineafter(b"Choice: ", b"1")
    io.sendlineafter(b"Enter a number: ", str(N).encode())
    q = int(io.recvline().strip())

    if q == 1:
        low = N
    else:
        high = N

secret_guess = low.to_integral_value(rounding=decimal.ROUND_CEILING)

io.sendlineafter(b"Choice: ", b"2")
io.sendlineafter(b"Enter secret number: ", str(secret_guess).encode())

print(io.recvall().decode().strip())
io.close()
```

---

## Crypto

### Secure Server

> John Doe uses this secure server where plaintext is never shared. Our Forensics Analyst was able to capture this traffic and the source code for the server. Can you recover John Doe's secrets?

When we follow TCP steam on the last packet in the pcap file, we get:
![Wireshark](/assets/images/scriptctf25/secureserver1.png)

Now reading the server file, we can see there is a simple XOR vulnerability. We can get the flag using this mathematical equation. It will make the keys cancel out and give us the flag.

S = enc ⊕ dec ⊕ enc2.

```python
from pwn import xor

enc_hex = "151e71ce4addf692d5bac83bb87911a20c39b71da3fa5e7ff05a2b2b0a83ba03"
enc2_hex = "e1930164280e44386b389f7e3bc02b707188ea70d9617e3ced989f15d8a10d70"
dec_hex = "87ee02c312a7f1fef8f92f75f1e60ba122df321925e8132068b0871ff303960e"

enc = bytes.fromhex(enc_hex)
enc2 = bytes.fromhex(enc2_hex)
dec = bytes.fromhex(dec_hex)

# secret = enc ⊕ dec ⊕ enc2
secret_bytes = xor(xor(enc, dec), enc2)

print(secret_bytes.decode())
```

### RSA-1

> Yú Tóngyī send a message to 3 peoples with unique modulus. But he left it vulnerable. Figure out `:)`

[Hastad’s broadcast situation.](https://docs.xanhacks.xyz/crypto/rsa/08-hastad-broadcast-attack/)

```python
#!/usr/bin/env python3
from math import isqrt

# Given values
n1 = 156503881374173899106040027210320626006530930815116631795516553916547375688556673985142242828597628615920973708595994675661662789752600109906259326160805121029243681236938272723595463141696217880136400102526509149966767717309801293569923237158596968679754520209177602882862180528522927242280121868961697240587
c1 = 77845730447898247683281609913423107803974192483879771538601656664815266655476695261695401337124553851404038028413156487834500306455909128563474382527072827288203275942719998719612346322196694263967769165807133288612193509523277795556658877046100866328789163922952483990512216199556692553605487824176112568965

n2 = 81176790394812943895417667822424503891538103661290067749746811244149927293880771403600643202454602366489650358459283710738177024118857784526124643798095463427793912529729517724613501628957072457149015941596656959113353794192041220905793823162933257702459236541137457227898063370534472564804125139395000655909
c2 = 40787486105407063933087059717827107329565540104154871338902977389136976706405321232356479461501507502072366720712449240185342528262578445532244098369654742284814175079411915848114327880144883620517336793165329893295685773515696260299308407612535992098605156822281687718904414533480149775329948085800726089284

n3 = 140612513823906625290578950857303904693579488575072876654320011261621692347864140784716666929156719735696270348892475443744858844360080415632704363751274666498790051438616664967359811895773995052063222050631573888071188619609300034534118393135291537302821893141204544943440866238800133993600817014789308510399
c3 = 100744134973371882529524399965586539315832009564780881084353677824875367744381226140488591354751113977457961062275480984708865578896869353244823264759044617432862876208706282555040444253921290103354489356742706959370396360754029015494871561563778937571686573716714202098622688982817598258563381656498389039630

e = 3

# Extended GCD and modular inverse
def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def invmod(a, m):
    x, _, g = egcd(a, m)
    if g != 1:
        raise Exception("no inverse")
    return x % m

# Chinese Remainder Theorem
N = n1 * n2 * n3
total = 0
for n, c in [(n1, c1), (n2, c2), (n3, c3)]:
    M = N // n
    inv = invmod(M, n)
    total = (total + c * M * inv) % N

# Integer k-th root
def iroot(k, n):
    low, high = 0, 1 << ((n.bit_length() // k) + 2)
    while low <= high:
        mid = (low + high) // 2
        p = mid**k
        if p == n:
            return mid, True
        if p < n:
            low = mid + 1
        else:
            high = mid - 1
    return high, False

# Recover message
m, _ = iroot(e, total)
pt = m.to_bytes((m.bit_length() + 7) // 8, "big")
print(pt.decode(errors="ignore"))
```

Flag: `scriptCTF{y0u_f0und_mr_yu's_s3cr3t_m3g_12a4e4}`

### MOD

> Just a simple modulo challenge

We can use this propery of mod to solve the challgene: `-1 % x = x-1`. PS: won't work in some languages like C, C++, Rust, etc.

```python
#!/usr/bin/env python3
from pwn import *

HOST, PORT = "play.scriptsorcerers.xyz", 10192

def solve():
    io = remote(HOST, PORT)

    io.recvuntil(b"Provide a number: ")
    io.sendline(b"-1")

    remainder = int(io.recvline().strip())
    secret = remainder + 1

    io.recvuntil(b"Guess: ")
    io.sendline(str(secret).encode())

    print(io.recvall(timeout=2).decode().strip())
    io.close()

if __name__ == "__main__":
    solve()
```

### Secure Server 2

> This time, the server is even more secure, but did it actually receive the secret? Simple brute-force won't work!

We can perform an AES MITM attack on this.

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES

def generate_aes_key(key_bytes):
    if len(key_bytes) != 2:
        raise ValueError("Key must be 2 bytes")
    bstr = bin(key_bytes[0])[2:].zfill(8) + bin(key_bytes[1])[2:].zfill(8)
    return bstr.encode()

def mitm(forward_text, backward_text, forward_op, backward_op):
    table = {}
    for i in range(1 << 16):
        k = i.to_bytes(2, "big")
        aes = AES.new(generate_aes_key(k), AES.MODE_ECB)
        table[forward_op(aes, forward_text)] = k

    for j in range(1 << 16):
        k = j.to_bytes(2, "big")
        aes = AES.new(generate_aes_key(k), AES.MODE_ECB)
        val = backward_op(aes, backward_text)
        if val in table:
            return table[val], k
    return None, None

if __name__ == "__main__":
    C1 = bytes.fromhex("19574ac010cc9866e733adc616065e6c019d85dd0b46e5c2190c31209fc57727")
    C2 = bytes.fromhex("0239bcea627d0ff4285a9e114b660ec0e97f65042a8ad209c35a091319541837")
    C3 = bytes.fromhex("4b3d1613610143db984be05ef6f37b31790ad420d28e562ad105c7992882ff34")

    k3, k4 = mitm(C1, C2, lambda c, t: c.encrypt(t), lambda c, t: c.decrypt(t))
    k1, k2 = mitm(C3, C2, lambda c, t: c.encrypt(t), lambda c, t: c.decrypt(t))

    if not all([k1, k2, k3, k4]):
        exit("[-] Could not recover all keys")

    P = AES.new(generate_aes_key(k1), AES.MODE_ECB).decrypt(
        AES.new(generate_aes_key(k2), AES.MODE_ECB).decrypt(C1)
    )

    msg = P.decode().strip()
    flag = f"{msg}{k1.decode()}{k2.decode()}{k3.decode()}{k4.decode()}}}"
    print("\n[+] Flag:", flag)
```

---

## Forensics

### diskchall

> i accidentally vanished my flag, can u find it for me

```bash
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ binwalk stick.img -e

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
404992        0x62E00         gzip compressed data, has original file name: "flag.txt", from Unix, last modified: 2025-07-17 22:27:22

┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ cat ./_stick.img.extracted/flag.txt
scriptCTF{1_l0v3_m461c_7r1ck5}
```
Flag: `scriptCTF{1_l0v3_m461c_7r1ck5}`

### pdf

> so sad cause no flag in pdf :(

```bash
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ binwalk challenge.pdf -e

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             PDF document, version: "1.4"
283           0x11B           Zlib compressed data, default compression
1521          0x5F1           Copyright string: "copyright/ordfeminine 172/logicalnot/.notdef/registered/macron/degree/plusminus/twosuperior/threesuperior/acute/mu 183/periodcen"

┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ cat ./_challenge.pdf.extracted/11B 
scriptCTF{pdf_s7r34m5_0v3r_7w17ch_5tr34ms}
```
Flag: `scriptCTF{pdf_s7r34m5_0v3r_7w17ch_5tr34ms}`

### Just Some Avocado

> just an innocent little avocado!

```bash
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ binwalk avocado.jpg -e

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
100599        0x188F7         Zip archive data, encrypted at least v1.0 to extract, compressed size: 234, uncompressed size: 222, name: justsomezip.zip
100922        0x18A3A         Zip archive data, encrypted at least v2.0 to extract, compressed size: 408140, uncompressed size: 437908, name: staticnoise.wav
                                            
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf]
└─$ cd _avocado.jpg.extracted 
                              
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf/_avocado.jpg.extracted]
└─$ fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt 188F7.zip

PASSWORD FOUND!!!!: pw == impassive3428
                                     
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf/_avocado.jpg.extracted]
└─$ unzip 188F7.zip      
Archive:  188F7.zip
[188F7.zip] justsomezip.zip password: 
 extracting: justsomezip.zip         
  inflating: staticnoise.wav         
```

We open staticnoise.wav in audacity and switch to spectrogram view.

![Static Noise](/assets/images/scriptctf25/staticnoise.png)

The password for justsomezip seems to be `d41v3ron`.

```bash
┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf/_avocado.jpg.extracted]
└─$ unzip justsomezip.zip 
Archive:  justsomezip.zip
[justsomezip.zip] flag.txt password: 
password incorrect--reenter: 
 extracting: flag.txt                

┌──(venv)─(kali㉿kali)-[~/ctf/scriptctf/_avocado.jpg.extracted]
└─$ cat flag.txt                      
scriptCTF{1_l0ve_d41_v3r0n}
```
Flag: `scriptCTF{1_l0ve_d41_v3r0n}`.

---

## Web

### Renderer

TODO, will write it soon.

---

## Programming

### Sums

>Find the sum of nums[i] for i in [l, r] (if there are any issues with input/output format, plz open a ticket)

```python
#!/usr/bin/env python3
from pwn import *

HOST = "play.scriptsorcerers.xyz"
PORT = 10010
context.timeout = 30

def solve():
    io = remote(HOST, PORT)

    # Receive the list of numbers
    nums = list(map(int, io.recvline(timeout=10).strip().split()))
    n = len(nums)

    # Build prefix sums
    prefix_sums = [0] * (n + 1)
    for i in range(n):
        prefix_sums[i + 1] = prefix_sums[i] + nums[i]

    # Answer n queries
    for _ in range(n):
        l, r = map(int, io.recvline(timeout=10).strip().split())
        io.sendline(str(prefix_sums[r + 1] - prefix_sums[l]))

    # Get the flag
    print(io.recvall(timeout=10).decode().strip())

if __name__ == "__main__":
    solve()
```

### More Divisors

>find length of the longest subsequence with gcd > 1 :)

```python
#!/usr/bin/env python3
from pwn import *
import math

def calculate_answer(numbers: list[int]) -> int:
    if not numbers:
        return 0

    non_zeros, count_zeros, max_val = [], 0, 0
    for x in numbers:
        if x == 0:
            count_zeros += 1
        else:
            num_abs = abs(x)
            non_zeros.append(num_abs)
            if num_abs > max_val:
                max_val = num_abs
    
    if max_val <= 1:
        return 0

    MAX = max_val + 1
    prime = [0] * MAX
    countdiv = [0] * MAX

    for i in range(2, math.isqrt(MAX)):
        if prime[i] == 0:
            for j in range(i * 2, MAX, i):
                prime[j] = i
    for i in range(1, MAX):
        if prime[i] == 0:
            prime[i] = i

    ans = 0
    for element in non_zeros:
        if element <= 1:
            continue
        temp_element = element
        while temp_element > 1:
            div = prime[temp_element]
            countdiv[div] += 1
            ans = max(ans, countdiv[div])
            while temp_element % div == 0:
                temp_element //= div
    
    if ans > 0:
        return ans + count_zeros
    if ans == 0 and any(n > 1 for n in non_zeros):
        return 1 + count_zeros
    return 0


def main():
    HOST, PORT = "play.scriptsorcerers.xyz", 10414
    with remote(HOST, PORT) as io:
        all_data = b""
        while True:
            try:
                chunk = io.recv(timeout=1.0)
                if chunk:
                    all_data += chunk
                else:
                    break
            except EOFError:
                break
        
        numbers = [int(x) for x in all_data.decode().strip().split()]
        answer = calculate_answer(numbers)
        io.sendline(str(answer).encode())
        print(io.recvall(timeout=2).decode().strip())


if __name__ == "__main__":
    main()
```